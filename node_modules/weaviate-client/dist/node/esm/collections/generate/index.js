var __awaiter =
  (this && this.__awaiter) ||
  function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P
        ? value
        : new P(function (resolve) {
            resolve(value);
          });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator['throw'](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
import { WeaviateInvalidInputError } from '../../errors.js';
import { toBase64FromMedia } from '../../index.js';
import { Deserialize } from '../deserialize/index.js';
import { Check } from '../query/check.js';
import { Serialize } from '../serialize/index.js';
class GenerateManager {
  constructor(check) {
    this.check = check;
  }
  static use(connection, name, dbVersionSupport, consistencyLevel, tenant) {
    return new GenerateManager(new Check(connection, name, dbVersionSupport, consistencyLevel, tenant));
  }
  parseReply(reply) {
    return __awaiter(this, void 0, void 0, function* () {
      const deserialize = yield Deserialize.use(this.check.dbVersionSupport);
      return deserialize.generate(reply);
    });
  }
  parseGroupByReply(opts, reply) {
    return __awaiter(this, void 0, void 0, function* () {
      const deserialize = yield Deserialize.use(this.check.dbVersionSupport);
      return Serialize.search.isGroupBy(opts)
        ? deserialize.generateGroupBy(reply)
        : deserialize.generate(reply);
    });
  }
  fetchObjects(generate, opts) {
    return this.check
      .fetchObjects(opts)
      .then(({ search }) =>
        search.withFetch(
          Object.assign(Object.assign({}, Serialize.search.fetchObjects(opts)), {
            generative: Serialize.generative(generate),
          })
        )
      )
      .then((reply) => this.parseReply(reply));
  }
  bm25(query, generate, opts) {
    return this.check
      .bm25(opts)
      .then(({ search }) =>
        search.withBm25(
          Object.assign(Object.assign({}, Serialize.search.bm25(query, opts)), {
            generative: Serialize.generative(generate),
          })
        )
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }
  hybrid(query, generate, opts) {
    return this.check
      .hybridSearch(opts)
      .then(({ search, supportsTargets, supportsVectorsForTargets, supportsWeightsForTargets }) =>
        search.withHybrid(
          Object.assign(
            Object.assign(
              {},
              Serialize.search.hybrid(
                {
                  query,
                  supportsTargets,
                  supportsVectorsForTargets,
                  supportsWeightsForTargets,
                },
                opts
              )
            ),
            { generative: Serialize.generative(generate) }
          )
        )
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }
  nearImage(image, generate, opts) {
    return this.check
      .nearSearch(opts)
      .then(({ search, supportsTargets, supportsWeightsForTargets }) =>
        toBase64FromMedia(image).then((image) =>
          search.withNearImage(
            Object.assign(
              Object.assign(
                {},
                Serialize.search.nearImage(
                  {
                    image,
                    supportsTargets,
                    supportsWeightsForTargets,
                  },
                  opts
                )
              ),
              { generative: Serialize.generative(generate) }
            )
          )
        )
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }
  nearObject(id, generate, opts) {
    return this.check
      .nearSearch(opts)
      .then(({ search, supportsTargets, supportsWeightsForTargets }) =>
        search.withNearObject(
          Object.assign(
            Object.assign(
              {},
              Serialize.search.nearObject(
                {
                  id,
                  supportsTargets,
                  supportsWeightsForTargets,
                },
                opts
              )
            ),
            { generative: Serialize.generative(generate) }
          )
        )
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }
  nearText(query, generate, opts) {
    return this.check
      .nearSearch(opts)
      .then(({ search, supportsTargets, supportsWeightsForTargets }) =>
        search.withNearText(
          Object.assign(
            Object.assign(
              {},
              Serialize.search.nearText(
                {
                  query,
                  supportsTargets,
                  supportsWeightsForTargets,
                },
                opts
              )
            ),
            { generative: Serialize.generative(generate) }
          )
        )
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }
  nearVector(vector, generate, opts) {
    return this.check
      .nearVector(vector, opts)
      .then(({ search, supportsTargets, supportsVectorsForTargets, supportsWeightsForTargets }) =>
        search.withNearVector(
          Object.assign(
            Object.assign(
              {},
              Serialize.search.nearVector(
                {
                  vector,
                  supportsTargets,
                  supportsVectorsForTargets,
                  supportsWeightsForTargets,
                },
                opts
              )
            ),
            { generative: Serialize.generative(generate) }
          )
        )
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }
  nearMedia(media, type, generate, opts) {
    return this.check
      .nearSearch(opts)
      .then(({ search, supportsTargets, supportsWeightsForTargets }) => {
        const args = {
          supportsTargets,
          supportsWeightsForTargets,
        };
        const generative = Serialize.generative(generate);
        let send;
        switch (type) {
          case 'audio':
            send = (media) =>
              search.withNearAudio(
                Object.assign(
                  Object.assign({}, Serialize.search.nearAudio(Object.assign({ audio: media }, args), opts)),
                  { generative }
                )
              );
            break;
          case 'depth':
            send = (media) =>
              search.withNearDepth(
                Object.assign(
                  Object.assign({}, Serialize.search.nearDepth(Object.assign({ depth: media }, args), opts)),
                  { generative }
                )
              );
            break;
          case 'image':
            send = (media) =>
              search.withNearImage(
                Object.assign(
                  Object.assign({}, Serialize.search.nearImage(Object.assign({ image: media }, args), opts)),
                  { generative }
                )
              );
            break;
          case 'imu':
            send = (media) =>
              search.withNearIMU(
                Object.assign(
                  Object.assign({}, Serialize.search.nearIMU(Object.assign({ imu: media }, args), opts)),
                  { generative }
                )
              );
            break;
          case 'thermal':
            send = (media) =>
              search.withNearThermal(
                Object.assign(
                  Object.assign(
                    {},
                    Serialize.search.nearThermal(Object.assign({ thermal: media }, args), opts)
                  ),
                  { generative }
                )
              );
            break;
          case 'video':
            send = (media) =>
              search.withNearVideo(
                Object.assign(
                  Object.assign({}, Serialize.search.nearVideo(Object.assign({ video: media }, args))),
                  { generative }
                )
              );
            break;
          default:
            throw new WeaviateInvalidInputError(`Invalid media type: ${type}`);
        }
        return toBase64FromMedia(media).then(send);
      })
      .then((reply) => this.parseGroupByReply(opts, reply));
  }
}
export default GenerateManager.use;
